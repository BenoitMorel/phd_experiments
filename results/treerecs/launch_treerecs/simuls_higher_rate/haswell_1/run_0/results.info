Start: 2018-08-02 08:52:05.817072
Command: scripts/treerecs/launch_treerecs.py simuls_higher_rate haswell 1

Experiment git: 
Git repo: git@github.com:BenoitMorel/phd_experiments.git
Git branch: master
Git commit: 13e8cedb61eaaee75b8c9680aac1653faca2461a
diff:
 		diff --git a/running.txt b/running.txt
		index 5c95f2a..142afca 100644
		--- a/running.txt
		+++ b/running.txt
		@@ -1,6 +1,4 @@
		 RUNNING:
		-/hits/basement/sco/morel/github/phd_experiments/results/pargenes/simuls/no_bootstraps/haswell_128/run_0
		-/hits/basement/sco/morel/github/phd_experiments/results/pargenes/simuls/bootstraps_100/haswell_512/run_0
		 
		 PAPER:
		   HEURISTIC RELEVANCE
		diff --git a/scripts/pargenes/pargenes.py b/scripts/pargenes/pargenes.py
		index fd8930b..4ffb933 100644
		--- a/scripts/pargenes/pargenes.py
		+++ b/scripts/pargenes/pargenes.py
		@@ -10,14 +10,10 @@ datas["128"]  = os.path.join(exp.datasets_root, "general/128//FastaFiles/")
		 datas["phyldog_example"]  = os.path.join(exp.datasets_root, "general/PhyldogDataExample/FastaFiles/")
		 datas["ensembl"]          = os.path.join(exp.bigdatasets_root, "ensembl_8880_15/fasta_files/")
		 datas["simuls"]          = os.path.join(exp.bigdatasets_root, "simuls/alignments/")
		+datas["simuls_higher_rate"]          = os.path.join(exp.bigdatasets_root, "simuls_higher_rate/alignments/")
		 datas["all"] = os.path.join(exp.bigdatasets_root, "all_1kite/split_alignment")
		 datas["all_filtered"] = os.path.join(exp.bigdatasets_root, "all_1kite/filtered_split_alignment")
		 datas["muscle"] = os.path.join(exp.bigdatasets_root, "eric_tannier/vectorbase_18/MUSCLE/")
		-datas["ensembl_1000_1"] = os.path.join(exp.bigdatasets_root, "ensembl_subsamples", "ensembl_subsample_1000_1/fasta_files/")
		-datas["ensembl_1000_2"] = os.path.join(exp.bigdatasets_root, "ensembl_subsamples", "ensembl_subsample_1000_2/fasta_files/")
		-datas["ensembl_1000_3"] = os.path.join(exp.bigdatasets_root, "ensembl_subsamples", "ensembl_subsample_1000_3/fasta_files/")
		-datas["ensembl_1000_4"] = os.path.join(exp.bigdatasets_root, "ensembl_subsamples", "ensembl_subsample_1000_4/fasta_files/")
		-datas["ensembl_1000_5"] = os.path.join(exp.bigdatasets_root, "ensembl_subsamples", "ensembl_subsample_1000_5/fasta_files/")
		 
		 datatypes = {}
		 datatypes["all"] = "aa"
		diff --git a/tools/treerecs/pargenes_to_treerecs.py b/tools/treerecs/pargenes_to_treerecs.py
		index 4be11b4..fe6af2f 100644
		--- a/tools/treerecs/pargenes_to_treerecs.py
		+++ b/tools/treerecs/pargenes_to_treerecs.py
		@@ -21,7 +21,7 @@ def get_alignment_dir(pargenes_dir):
		 
		 if (len(sys.argv) != 3):
		   print("Syntax: python pargenes_to_treerecs.py pargenes_dir treerecs_dir")
		-
		+  sys.exit(1)
		 pargenes_dir = sys.argv[1]
		 treerecs_dir = sys.argv[2]
		 
		

Treerecs git: 
Git repo: git@gitlab.inria.fr:Phylophile/Treerecs.git
Git branch: threshold_selection
Git commit: 2497d344a45f873837a6f5e0784bcb0c8afe5fa9
diff:
 		diff --git a/src/Treerecs.cpp b/src/Treerecs.cpp
		index 86be523..a794de8 100644
		--- a/src/Treerecs.cpp
		+++ b/src/Treerecs.cpp
		@@ -180,6 +180,9 @@ inline void print_help(char* prog_path) {
		 
		 //  std::cout << "   --stats\n\tprint in file statistics of resulting trees.\n" << std::endl;
		 
		+  std::cout << "   --select-best-tree" << std::endl;
		+  std::cout << "\tfor each input gene tree, select the best likelihood corrected tree. Output them in an additional file.\n" << std::endl;
		+  
		   std::cout << "   --inferior-than-threshold-only" << std::endl;
		   std::cout << "\tcontract branches with a support inferior only than the threshold.\n" << std::endl;
		   std::cout << "                                                                                                 " << std::endl;
		@@ -335,7 +338,7 @@ void get_best_likelihood_solutions(const TreeSolutions &solutions,
		   for (const auto &familySolutions: solutions) {
		     const ReconciledRootedTree *best_tree = 0;
		     double best_loglk = -std::numeric_limits<double>::max();
		-    double best_threshold = 0.0;
		+    double select_best_tree = 0.0;
		     for (const auto &threshold_solutions: familySolutions.second){
		       for (const auto &reconciledTree: threshold_solutions.second) {
		         double loglk = reconciledTree.joint_loglikelihood();
		@@ -343,13 +346,13 @@ void get_best_likelihood_solutions(const TreeSolutions &solutions,
		         if (loglk > best_loglk) {
		           best_tree = &reconciledTree;
		           best_loglk = loglk;
		-          best_threshold = threshold_solutions.first;
		+          select_best_tree = threshold_solutions.first;
		         }
		       }
		     }
		     best_solutions.insert(TreeSolution());
		     auto &best_solution = best_solutions[familySolutions.first];    
		-    best_solution.insert(std::make_pair(best_threshold, std::vector<ReconciledRootedTree>(1, *best_tree)));
		+    best_solution.insert(std::make_pair(select_best_tree, std::vector<ReconciledRootedTree>(1, *best_tree)));
		   }
		 }
		 
		@@ -400,7 +403,7 @@ int main(int argc, char * argv[]) {
		   bool allows_progression_print = true;
		   bool add_ale_evaluation = false;
		   bool ale_selection = false;
		-  bool best_threshold = false;
		+  bool select_best_tree = false;
		   bool statistics = false;
		   long int seed = time(NULL);
		   bool seed_set = false;
		@@ -433,7 +436,7 @@ int main(int argc, char * argv[]) {
		       {"costs-estimation",  no_argument,       NULL,  'C'},
		       {"ale-evaluation",    no_argument,       NULL,   0 },
		       {"ale-selection",     no_argument,       NULL,   0 },
		-      {"best-threshold",     no_argument,       NULL,   0 },
		+      {"select-best-tree",     no_argument,       NULL,   0 },
		       {"tree-index",        required_argument, NULL,  'N'},
		       #if defined(_OPENMP) && !defined(__clang__)
		         {"parallelize",     no_argument,       NULL,  'P'},
		@@ -479,8 +482,8 @@ int main(int argc, char * argv[]) {
		           add_ale_evaluation = true;
		           ale_selection = true;
		         }
		-        else if(strcmp(long_options_lists[option_index].name, "best-threshold") == 0) {
		-          best_threshold = true;
		+        else if(strcmp(long_options_lists[option_index].name, "select-best-tree") == 0) {
		+          select_best_tree = true;
		         }
		         else if(strcmp(long_options_lists[option_index].name, "stats") == 0) {
		           statistics = true;
		@@ -1191,7 +1194,7 @@ int main(int argc, char * argv[]) {
		     IO::writeReconciledTrees(output_filename, trees_solutions, genetrees, *speciestree,
		                              text_format, not output_without_description);
		       
		-    if (best_threshold) {
		+    if (select_best_tree) {
		       TreeSolutions best_trees_solutions;
		       get_best_likelihood_solutions(trees_solutions, best_trees_solutions);
		       IO::writeReconciledTrees(output_filename + ".best", best_trees_solutions, genetrees, *speciestree,
		diff --git a/src/treerecs/tools/LibpllEvaluation.cpp b/src/treerecs/tools/LibpllEvaluation.cpp
		index a9f781b..5715ea4 100644
		--- a/src/treerecs/tools/LibpllEvaluation.cpp
		+++ b/src/treerecs/tools/LibpllEvaluation.cpp
		@@ -24,7 +24,7 @@ const double TOLERANCE = 0.5;
		 #define RAXML_BRLEN_SMOOTHINGS    32
		 #define RAXML_BRLEN_DEFAULT       0.1
		 #define RAXML_BRLEN_MIN           1.0e-6
		-#define RAXML_BRLEN_MAX           100.
		+#define RAXML_BRLEN_MAX           1000.
		 #define RAXML_BRLEN_TOLERANCE     1.0e-7
		 #define RAXML_FREERATE_MIN        0.001
		 #define RAXML_FREERATE_MAX        100.
		@@ -114,13 +114,21 @@ shared_ptr<LibpllEvaluation> LibpllEvaluation::buildFromString(const string &new
		   pllmod_subst_model_t *model = getModel(modelStr);
		   unsigned int statesNumber = model->states;
		   const pll_state_t *charmap = (statesNumber == 4) ? pll_map_nt : pll_map_aa; 
		-  try {  
		-    parsePhylip(alignmentFilename.c_str(), 
		-        charmap, sequences,
		-        patternWeights);
		-  } catch (...) {
		-    parseFasta(alignmentFilename.c_str(), 
		-        charmap, sequences, patternWeights);
		+  pll_rtree_t * rtree = 0;
		+  #if defined(_OPENMP)
		+  # pragma omp critical
		+  #endif
		+  {
		+    try {  
		+      parsePhylip(alignmentFilename.c_str(), 
		+          charmap, sequences,
		+          patternWeights);
		+    } catch (...) {
		+      parseFasta(alignmentFilename.c_str(), 
		+          charmap, sequences, patternWeights);
		+    }
		+    // tree
		+    rtree = pll_rtree_parse_newick_string(newickString.c_str());
		   }
		   // partition
		   unsigned int attribute = getBestLibpllAttribute();
		@@ -166,8 +174,6 @@ shared_ptr<LibpllEvaluation> LibpllEvaluation::buildFromString(const string &new
		     pll_set_subst_params(partition, 0, model->rates);
		   }
		   
		-  // tree
		-  pll_rtree_t * rtree = pll_rtree_parse_newick_string(newickString.c_str());
		   if (!rtree) 
		     throw LibpllException("Error in pll_rtree_parse_newick_string on ", newickString);
		   pll_utree_t * utree = pll_rtree_unroot(rtree);
		
